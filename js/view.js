// Generated by CoffeeScript 1.10.0
(function() {
  var Player, Stats, init, initRandomVariables, randomInt, toggleBreakpoints, toggleComment;

  Player = (function() {
    function Player(tree1, scope1) {
      this.tree = tree1;
      this.scope = scope1;
      this.curScope = $('#scope-' + this.scope);
      this.memory = this.tree.memory;
      this.stats = new Stats(this.memory, this.scope);
      this.speed = this.loadSpeed();
      this.breaks = this.loadBreaks();
      this.tempo = 0;
      this.reset();
    }

    Player.prototype.reset = function() {
      if (this.timer != null) {
        this.play();
      }
      this.tree.reset();
      this.stats.reset();
      $('#scopes-head').children(':gt(' + this.scope + ')').remove();
      $('#scopes-body').children(':gt(' + this.scope + ')').remove();
      this.curScope.find('.return-value').val('');
      this.curNode = null;
      this.nextNode = this.tree.mark(this, this.tree.root);
      this.nextCandidate = null;
      this.cursorState = 0;
      this.clearHighlight();
      if (this.nextNode >= 0) {
        this.setControls([0, 1, 1, 1]);
      } else {
        this.setControls([0, 0, 0, 0]);
      }
      return $('#alert').hide('slow');
    };

    Player.prototype.play = function() {
      var maxSteps;
      if (this.timer != null) {
        this.timer = clearInterval(this.timer);
        this.curScope.find('.img-play').removeClass('glyphicon-pause').addClass('glyphicon-play');
        return this.tempo = 0;
      } else {
        maxSteps = window.defaults.maxSteps;
        this.playStep = 0;
        this.timer = setInterval((function(_this) {
          return function() {
            if (_this.playStep <= maxSteps) {
              _this.step();
              return _this.playStep++;
            } else {
              return _this.handleError(new ExecutionError('too_many_steps', [maxSteps]));
            }
          };
        })(this), this.speed);
        this.curScope.find('.img-play').removeClass('glyphicon-play').addClass('glyphicon-pause');
        return this.tempo = 1;
      }
    };

    Player.prototype.step = function() {
      var curNode, error1, runtimeError, tempo, value;
      this.clearHighlight();
      if (this.cursorState === 0) {
        this.curNode = this.nextNode;
        try {
          curNode = this.tree.execute(this, this.curNode);
          if ((curNode.scope != null)) {
            this.curNode = curNode.node;
            this.callFunction(curNode.scope, curNode.params);
            return;
          }
          if ((curNode.next != null) && curNode.next >= 0) {
            this.nextCandidate = curNode.next;
          } else {
            this.nextCandidate = null;
          }
        } catch (error1) {
          runtimeError = error1;
          this.handleError(runtimeError);
          this.setControls([1, 0, 0, 0]);
          return false;
        }
        if (this.curScope.find('.stop-after').is(':checked')) {
          this.cursorState = 1;
          this.setCursor(this.curNode, this.cursorState);
          return true;
        }
      }
      if ((this.nextCandidate != null)) {
        this.cursorState = 0;
        this.nextNode = this.tree.mark(this, this.nextCandidate);
        this.setControls([1, 1, 1, 1]);
        if (this.curScope.find('.stop-before').is(':checked')) {
          return true;
        } else {
          return this.step();
        }
      } else {
        tempo = this.tempo;
        if (this.timer != null) {
          this.play();
        }
        this.unsetCursor();
        this.setControls([1, 0, 0, 0]);
        if (this.scope > 0) {
          value = this.curScope.find('.return-value').val();
          window.players[this.scope - 1].returnFunction(this.scope, value, tempo);
        }
        return false;
      }
    };

    Player.prototype.finish = function() {
      var i, j, maxSteps, ref;
      this.tempo = 2;
      maxSteps = window.defaults.maxSteps;
      for (i = j = 0, ref = maxSteps; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        if (!this.step()) {
          return;
        }
      }
      return this.handleError(new ExecutionError('too_many_steps', [maxSteps]));
    };

    Player.prototype.callFunction = function(scope, params) {
      var player;
      this.setControls([0, 0, 0, 0]);
      if (this.timer != null) {
        this.play();
        this.tempo = 1;
      }
      init(scope, this.tempo);
      player = players[scope];
      $('#scope-' + scope).find('.variables .parameter').each(function() {
        var value, vid;
        vid = $(this).data('vid');
        value = params.shift().value;
        player.memory.set(vid, value);
        return player.stats.writeVar(vid, value);
      });
      return $('#scopes-head .scope-' + scope).tab('show');
    };

    Player.prototype.returnFunction = function(scope, value, tempo) {
      $('#scopes-head .scope-' + this.scope).tab('show');
      $('#scopes-head .scope-' + scope).parent().remove();
      $('#scope-' + scope).remove();
      window.players[scope + 1] = null;
      this.curScope.find('.node_' + this.curNode).data('return-value', value);
      this.setControls([1, 1, 1, 1]);
      switch (tempo) {
        case 2:
          return this.finish();
        case 1:
          return this.play();
        default:
          this.tempo = tempo;
          return this.step();
      }
    };

    Player.prototype.changeSpeed = function(value) {
      this.speed = value;
      this.play();
      this.play();
      if ((typeof localStorage !== "undefined" && localStorage !== null)) {
        return localStorage.setItem('speed', value);
      }
    };

    Player.prototype.loadSpeed = function() {
      var speed;
      if ((typeof localStorage !== "undefined" && localStorage !== null) && ((speed = localStorage.getItem('speed')) != null)) {
        return speed;
      } else {
        return window.defaults.speed;
      }
    };

    Player.prototype.changeBreaks = function(status) {
      if ((typeof localStorage !== "undefined" && localStorage !== null)) {
        return localStorage.setItem('breaks', status);
      }
    };

    Player.prototype.loadBreaks = function() {
      var breaks, localBreaks;
      if ((typeof localStorage !== "undefined" && localStorage !== null) && ((localBreaks = localStorage.getItem('breaks')) != null)) {
        breaks = localBreaks;
      } else {
        breaks = window.defaults.breaks;
      }
      this.changeBreaks(breaks);
      if (breaks === 'before' || breaks === 'both') {
        this.curScope.find('.stop-before').prop('checked', true);
        this.curScope.find('.stop-before-btn').addClass('active');
      }
      if (breaks === 'after' || breaks === 'both') {
        this.curScope.find('.stop-after').prop('checked', true);
        this.curScope.find('.stop-after-btn').addClass('active');
      }
      return breaks;
    };

    Player.prototype.handleError = function(error) {
      var msg;
      msg = errorCodes[error.message];
      if ((msg != null)) {
        $.each(error.parts, function(index, elem) {
          return msg = msg.replace(new RegExp('%' + (index + 1), 'g'), elem);
        });
      } else {
        msg = errorCodes['undefined'];
        console.error(error);
      }
      $('#alertText').html(msg);
      return $('#alert').show('slow');
    };

    Player.prototype.clearHighlight = function() {
      this.curScope.find('.highlight-write').removeClass('highlight-write');
      return this.curScope.find('.highlight-read').removeClass('highlight-read');
    };

    Player.prototype.setControls = function(settings) {
      var buttons, i, j, ref, results;
      buttons = this.curScope.find('.controls button');
      results = [];
      for (i = j = 0, ref = buttons.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        if (settings[i] === 0) {
          results.push($(buttons[i]).attr('disabled', 'disabled'));
        } else {
          results.push($(buttons[i]).removeAttr('disabled'));
        }
      }
      return results;
    };


    /*
      node = node_id of the node the cursor should be attached to
      position = the position of the cursor: 0 => before statement, 1 => after statement
     */

    Player.prototype.setCursor = function(node, position) {
      var newClass;
      switch (position) {
        case 0:
          newClass = 'cursor-up';
          break;
        case 1:
          newClass = 'cursor-down';
      }
      this.unsetCursor();
      this.curScope.find('.node_' + node).addClass('cursor ' + newClass);
      return this.curScope.find('.source-node-' + node).closest('.line').addClass('source-cursor ' + newClass);
    };

    Player.prototype.unsetCursor = function() {
      this.curScope.find('.cursor').removeClass('cursor cursor-up cursor-down');
      return this.curScope.find('.source-cursor').removeClass('source-cursor cursor-up cursor-down');
    };

    return Player;

  })();

  Stats = (function() {
    function Stats(memory, scope1) {
      this.memory = memory;
      this.scope = scope1;
      this.curScope = $('#scope-' + this.scope);
      this.stats = ['accesses', 'assignments', 'comparisons', 'arithmeticLogic'];
    }

    Stats.prototype.inc = function(element) {
      var elem, value;
      elem = this.curScope.find('.stats-' + element);
      value = parseInt(elem.val()) + 1;
      return elem.val(value).addClass('highlight-write');
    };

    Stats.prototype.incAccessOps = function() {
      return this.inc(this.stats[0]);
    };

    Stats.prototype.incAssignOps = function() {
      return this.inc(this.stats[1]);
    };

    Stats.prototype.incCompareOps = function() {
      return this.inc(this.stats[2]);
    };

    Stats.prototype.incArithmeticLogicOps = function() {
      return this.inc(this.stats[3]);
    };

    Stats.prototype.readVar = function(vid) {
      this.curScope.find('.var-' + vid + ' .value-container').addClass('highlight-read');
      return this.incAccessOps();
    };

    Stats.prototype.readArrayVar = function(vid, index) {
      this.curScope.find('.var-' + vid + ' .offset_' + index).addClass('highlight-read');
      return this.incAccessOps();
    };

    Stats.prototype.writeGeneric = function(container, value) {
      container.removeClass('highlight-read').addClass('highlight-write');
      container.find('.value').text(value);
      return this.incAssignOps();
    };

    Stats.prototype.writeVar = function(vid, value) {
      var container;
      container = this.curScope.find('.var-' + vid + ' .value-container');
      return this.writeGeneric(container, value);
    };

    Stats.prototype.writeArrayVar = function(vid, index, value) {
      var container;
      container = this.curScope.find('.var-' + vid + ' .offset_' + index);
      return this.writeGeneric(container, value);
    };

    Stats.prototype.reset = function() {
      $.each(this.memory.memory, (function(_this) {
        return function(index, elem) {
          var row, values;
          row = _this.curScope.find('.var-' + index);
          if (elem.array) {
            values = elem.value.split(',');
            return $.each(values, function(i, n) {
              return row.find(".offset_" + i + ">.value").text(n);
            });
          } else {
            return row.find('.value').text(elem.value);
          }
        };
      })(this));
      return $.each(this.stats, (function(_this) {
        return function(index, elem) {
          return _this.curScope.find('.stats-' + elem).val(0);
        };
      })(this));
    };

    return Stats;

  })();


  /*
    Deal with the breakpoint buttons and compute a valid state ('none' forbidden)
   */

  toggleBreakpoints = function(button, player) {
    var curScope, statusAfter, statusBefore;
    curScope = $('#scope-' + player.scope);
    statusBefore = curScope.find('.stop-before-btn').hasClass('active');
    statusAfter = curScope.find('.stop-after-btn').hasClass('active');
    if (button.data('break') === 'before') {
      statusBefore = !statusBefore;
    }
    if (button.data('break') === 'after') {
      statusAfter = !statusAfter;
    }
    if (statusBefore && statusAfter) {
      return player.changeBreaks('both');
    } else if (statusBefore) {
      return player.changeBreaks('before');
    } else if (statusAfter) {
      return player.changeBreaks('after');
    } else {
      return button.button('toggle');
    }
  };

  toggleComment = function(element) {
    var autoHeight, container, curHeight, newHeight;
    container = element.parent();
    element.toggleClass('fa-plus-square fa-minus-square');
    if (container.hasClass('collapsed')) {
      curHeight = container.height();
      container.css('height', 'auto');
      autoHeight = container.height();
      container.css('height', curHeight);
      newHeight = autoHeight;
    } else {
      newHeight = '20px';
    }
    return container.animate({
      height: newHeight
    }, 'slow', 'linear', function() {
      return container.toggleClass('collapsed');
    });
  };

  randomInt = function() {
    return Math.floor(Math.random() * (window.defaults.maxRandInt + 1));
  };

  initRandomVariables = function(scope) {
    return scope.find('.variable.random').each(function() {
      var value, values;
      switch ($(this).data('type')) {
        case 'elem-int':
          value = randomInt();
          $(this).find('.value').text(value);
          return $(this).data('value', value);
        case 'array-int':
          values = [];
          $(this).find('.value-container').each(function() {
            value = randomInt();
            $(this).find('.value').text(value);
            return values.push(value);
          });
          return $(this).data('value', values.join(','));
      }
    });
  };

  init = function(scope, tempo) {
    var curScope, player, tree;
    curScope = $('#scope-' + scope);
    initRandomVariables(curScope);
    tree = new Tree(scope);
    player = new Player(tree, scope);
    window.players[scope] = player;
    curScope.find('.btn-reset').click(function() {
      return player.reset();
    });
    curScope.find('.btn-play').click(function() {
      return player.play();
    });
    curScope.find('.btn-step').click(function() {
      return player.step();
    });
    curScope.find('.btn-finish').click(function() {
      return player.finish();
    });
    curScope.find('.speed-slider').slider({
      value: parseInt(1000 / player.speed),
      min: 1,
      max: 20,
      change: function(event, ui) {
        return player.changeSpeed(1000 / ui.value);
      }
    });
    curScope.find('.stop-before-btn, .stop-after-btn').click(function() {
      return toggleBreakpoints($(this), player);
    });
    curScope.find('.toggle-comment').click(function() {
      return toggleComment($(this));
    });
    curScope.find('.value-container').click(function() {
      var input, offset, value;
      value = $(this).hide().find('.value').text();
      if ((offset = $(this).data('offset')) != null) {
        input = $(this).siblings('.value-edit.offset_' + offset);
      } else {
        input = $(this).siblings('.value-edit');
      }
      return input.val(value).show().focus();
    });
    curScope.find('.value-edit').keyup(function(event) {
      var index, newVal, offset, vid;
      switch (event.which) {
        case 13:
          if ((newVal = DataType.parse($(this).val()))) {
            if ((offset = $(this).data('offset')) != null) {
              vid = $(this).closest('.variable').data('vid');
              index = $(this).data('offset');
              player.memory.arraySet(vid, index, newVal.value);
              player.stats.writeArrayVar(vid, index, newVal.value);
            } else {
              vid = $(this).closest('.variable').data('vid');
              player.memory.set(vid, newVal.value);
              player.stats.writeVar(vid, newVal.value);
            }
          } else {
            alert(window.l10n['invalid_value'].replace('%1', $(this).val()));
          }
          return $(this).blur();
        case 27:
          return $(this).blur();
      }
    }).blur(function() {
      return $(this).hide().siblings('.value-container').show();
    });
    switch (tempo) {
      case 1:
        return player.play();
      case 2:
        return player.finish();
    }
  };

  $(function() {
    window.players = {};
    return init(0, 0);
  });

}).call(this);
