// Generated by CoffeeScript 1.10.0
(function() {
  var AssignNode, BlockNode, CommentNode, CompareNode, FunctionNode, IfNode, IncNode, Node, ReturnNode, SwapNode, ValueNode, WhileNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Node = (function() {
    function Node() {}


    /*
      Must be overridden by all subclasses.
     */

    Node.prototype.execute = function(player, node) {
      throw new Error('Node must override execute() method!');
    };


    /*
      This method executes the index part of an array access.
     */

    Node.prototype.executeIndex = function(variable, player) {
      if (variable.kind === 'const' && variable.type === 'int') {
        return variable.value;
      } else if (variable.kind === 'var') {
        player.stats.readVar(variable.vid);
        return player.memory.get(variable.vid).value;
      } else if (variable.kind === 'comp') {
        return this.executeValue(variable, player);
      } else {
        throw new ExecutionError('unsupported_index', [variable.kind]);
      }
    };

    Node.prototype.executeValue = function(value, player) {
      var leftVal, rightVal, variable;
      if ((value != null ? value.kind : void 0) == null) {
        throw new ExecutionError('could_not_execute_value', [value]);
      }
      switch (value.kind) {
        case 'const':
          return value.value;
        case 'index':
          return this.readVar(value, player);
        case 'prop':
          if (value.prop === 'length') {
            variable = player.memory.get(value.vid);
            if (variable.array) {
              return variable.value.split(',').length;
            } else {
              return 1;
            }
          } else {
            throw new ExecutionError('unknown_property', [value.prop]);
          }
          break;
        case 'var':
          return this.readVar(value, player);
        case 'comp':
          leftVal = this.executeValue(value.left, player);
          rightVal = this.executeValue(value.right, player);
          player.stats.incArithmeticLogicOps();
          switch (value.op) {
            case '+':
              return leftVal + rightVal;
            case '-':
              return leftVal - rightVal;
            case '*':
              return leftVal * rightVal;
            case '/':
              if (rightVal === 0) {
                throw new ExecutionError('divide_by_zero', []);
              }
              return parseInt(leftVal / rightVal);
            case '%':
              return leftVal % rightVal;
            case '&':
              return leftVal && rightVal;
            case '|':
              return leftVal || rightVal;
            default:
              throw new ExecutionError('unknown_arithmetic_op', [this.operator]);
          }
          break;
        default:
          throw new ExecutionError('unknown_kind', [value.kind]);
      }
    };

    Node.prototype.readVar = function(source, player) {
      var index, vid;
      switch (source.kind) {
        case 'index':
          index = this.executeIndex(source.index, player);
          player.stats.readArrayVar(source.vid, index);
          return player.memory.arrayGet(source.vid, index);
        case 'var':
          vid = source.vid;
          player.stats.readVar(vid);
          return player.memory.get(vid).value;
        default:
          throw new ExecutionError('unknown_kind', [source.kind]);
      }
    };

    Node.prototype.writeVar = function(destination, value, player) {
      var index;
      switch (destination.kind) {
        case 'index':
          index = this.executeIndex(destination.index, player);
          player.memory.arraySet(destination.vid, index, value);
          return player.stats.writeArrayVar(destination.vid, index, value);
        case 'var':
          player.memory.set(destination.vid, value);
          return player.stats.writeVar(destination.vid, value);
        case 'const':
          throw new ExecutionError('assign_to_const', [destination.value]);
          break;
        case 'prop':
          throw new ExecutionError('assign_to_prop', []);
          break;
        default:
          throw new ExecutionError('unknown_kind', [destination.kind]);
      }
    };


    /*
      Sets the cursor to the position of the node. Override to place it somewhere else!
     */

    Node.prototype.mark = function(player, node) {
      if (node === this.nid) {
        player.setCursor(this.nid, 0);
        return this.nid;
      } else {
        return -1;
      }
    };


    /*
      Must be overridden by all subclasses.
     */

    Node.prototype.toJSON = function() {
      throw new Error('Node must override toJSON() method!');
    };


    /*
      Delegates the parse function to the right subclass.
      Must be overridden by all subclasses.
     */

    Node.parse = function(node, tree, memory) {
      var type;
      type = node.data('node-type');
      switch (type) {
        case 'assign':
          return AssignNode.parse(node, tree, memory);
        case 'comment':
          return CommentNode.parse(node, tree, memory);
        case 'compare':
          return CompareNode.parse(node, tree, memory);
        case 'function':
          return FunctionNode.parse(node, tree, memory);
        case 'if':
          return IfNode.parse(node, tree, memory);
        case 'inc':
          return IncNode.parse(node, tree, memory);
        case 'return':
          return ReturnNode.parse(node, tree, memory);
        case 'swap':
          return SwapNode.parse(node, tree, memory);
        case 'value':
          return ValueNode.parse(node, tree, memory);
        case 'while':
          return WhileNode.parse(node, tree, memory);
        default:
          throw new Error("Parse error: unknown type: '" + type + "'");
      }
    };


    /*
     * For combo boxes: Inspects the given value and defines its kind
     * and properties.
     */

    Node.parseAndCheckValue = function(_class, node, memory) {
      var value;
      node = this.findSubNode(node, _class);
      value = this.parseValue(node.val(), memory);
      if (value == null) {
        node.addClass('error');
      } else {
        node.removeClass('error');
      }
      return value;
    };

    Node.parseAndCheckVar = function(_class, node, memory) {
      var value;
      node = this.findSubNode(node, _class);
      value = this.parseValue(node.val(), memory);
      if ((value != null) && (value.kind === 'var' || value.kind === 'index')) {
        node.removeClass('error');
        return value;
      } else {
        node.addClass('error');
        return null;
      }
    };

    Node.parseValue = function(value, memory) {
      var close, constant, inner, left, op, open, period, right, split, vid;
      value = $.trim(value);
      if ((constant = DataType.parse(value))) {
        return {
          kind: 'const',
          type: constant.type,
          value: constant.value
        };
      }
      open = value.indexOf('[');
      close = value.lastIndexOf(']');
      if (open > -1 && close > open) {
        vid = memory.find(value.substr(0, open));
        inner = this.parseValue(value.substr(open + 1, close - open - 1), memory);
        if (vid > -1 && (inner != null)) {
          memory.count(vid);
          return {
            kind: 'index',
            vid: vid,
            index: inner
          };
        } else {
          return null;
        }
      }
      period = value.indexOf('.');
      if (period > -1 && value.substr(period + 1) === "length") {
        vid = memory.find(value.substr(0, period));
        if (vid > -1) {
          memory.count(vid);
          return {
            kind: 'prop',
            type: 'int',
            vid: vid,
            prop: 'length'
          };
        } else {
          return null;
        }
      }
      if (/^[A-Za-z]+$/.test(value)) {
        vid = memory.find(value);
        if (vid > -1) {
          memory.count(vid);
          return {
            kind: 'var',
            vid: vid
          };
        } else {
          return null;
        }
      }
      value = value.replace(/\s*/g, '');
      if (value.indexOf('(') === -1) {
        split = value.split(/(-|\+|\*|\/|%|&|\|)/i);
        if (split.length === 3) {
          left = this.parseValue(split[0], memory);
          right = this.parseValue(split[2], memory);
          if ((left != null) && (right != null) && "+-*/%&|".indexOf(split[1]) >= 0) {
            return {
              kind: 'comp',
              left: left,
              right: right,
              op: split[1]
            };
          } else {
            return null;
          }
        }
      }
      if ((value = this.parsePars(value)) != null) {
        switch ((Object.keys(value).length)) {
          case 1:
            return this.parseValue(value[0], memory);
          case 3:
            left = this.parseValue(value[0], memory);
            right = this.parseValue(value[2], memory);
            op = value[1];
            if ((left != null) && (right != null) && "+-*/%&|".indexOf(value[1]) >= 0) {
              return {
                kind: 'comp',
                left: left,
                right: right,
                op: op
              };
            }
        }
      }
      return null;
    };


    /*
      Deals with complex binary expressions within parenthesis. It goes one level
      deep (say: not recursive). Returns an object with one value if it is just
      a simple expression within parenthesis. It the expression is more complex,
      it returns an object of size 3 that contains two expressions left, right along
      with the used operator.
     */

    Node.parsePars = function(value) {
      var chunk, i, index, j, level, ref, result, split;
      level = 0;
      result = {};
      index = 0;
      split = value.split(/(-|\+|\*|\/|%|&|\||\(|\))/g);
      for (i = j = 0, ref = split.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        chunk = split[i];
        if (chunk === '') {
          continue;
        }
        if (level === 0) {
          if (chunk === '(') {
            level++;
          } else if (chunk === ')') {
            level--;
          } else {
            result[index++] = chunk;
          }
        } else {
          if (chunk === '(') {
            level++;
          } else if (chunk === ')') {
            if (--level === 0) {
              index++;
              continue;
            }
          }
          if ((result[index] != null)) {
            result[index] += chunk;
          } else {
            result[index] = chunk;
          }
        }
      }
      if (level !== 0) {
        console.log("Unbalanced");
        return null;
      } else {
        return result;
      }
    };


    /*
     * Returns node's first sub-node of class _class.
     */

    Node.findSubNode = function(node, _class) {
      return node.find(_class + ':first');
    };

    Node.validate = function(node, check) {
      var flag;
      flag = node.find('.invalid-flag:first');
      if (check) {
        node.removeClass('invalid');
        return flag.hide();
      } else {
        node.addClass('invalid');
        return flag.show();
      }
    };

    return Node;

  })();

  AssignNode = (function(superClass) {
    extend(AssignNode, superClass);

    function AssignNode(nid1, from1, to1) {
      this.nid = nid1;
      this.from = from1;
      this.to = to1;
    }

    AssignNode.prototype.execute = function(player, node) {
      node = player.tree.get(this.from).execute(player, 0);
      if (node.scope == null) {
        this.writeVar(this.to, node.value, player);
      }
      return node;
    };

    AssignNode.prototype.toJSON = function() {
      return {
        nid: this.nid,
        node: 'assign',
        from: this.from,
        to: this.to
      };
    };

    AssignNode.parse = function(node, tree, memory) {
      var from, nid, to;
      from = BlockNode.parse(AssignNode.findSubNode(node, '.assign-from'), tree, memory);
      tree.push(from);
      to = AssignNode.parseAndCheckVar('.assign-to', node, memory);
      AssignNode.validate(node, (to != null) && from.size());
      nid = tree.length;
      return new AssignNode(nid, from.nid, to);
    };

    return AssignNode;

  })(Node);

  BlockNode = (function(superClass) {
    extend(BlockNode, superClass);

    function BlockNode(nid1, nodes1) {
      this.nid = nid1;
      this.nodes = nodes1;
      this.curNode = 0;
    }

    BlockNode.prototype.execute = function(player, node) {
      var curNode, i, j, len, n, ref, value;
      curNode = null;
      ref = this.nodes;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        n = ref[i];
        if (node <= n) {
          curNode = player.tree.get(n).execute(player, node);
          break;
        }
      }
      if (((curNode != null ? curNode.value : void 0) != null)) {
        value = curNode.value;
      } else {
        value = false;
      }
      if (((curNode != null ? curNode.scope : void 0) != null)) {
        return curNode;
      } else if (((curNode != null ? curNode.next : void 0) != null)) {
        return {
          next: curNode.next,
          value: value
        };
      } else if (curNode === -1) {
        return {
          next: -1,
          value: value
        };
      } else if (this.nodes.length > i + 1) {
        return {
          next: this.nodes[i + 1],
          value: value
        };
      } else {
        return {
          value: value
        };
      }
    };

    BlockNode.prototype.executeAll = function(player, node, combine) {
      var curValue, i, j, len, n, next, ref, value;
      value = combine === 'all';
      next = -1;
      ref = this.nodes;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        n = ref[i];
        if (node < n) {
          next = n;
          break;
        } else {
          curValue = player.tree.get(n).execute(player, n).value;
          if (combine === 'all') {
            value = value && curValue;
          }
          if (combine === 'any') {
            value = value || curValue;
          }
          if (window.defaults.shortCircuit && !value) {
            break;
          }
        }
      }
      return {
        value: value,
        next: next
      };
    };

    BlockNode.prototype.mark = function(player, node) {
      var i, j, k, len, len1, marked, n, ref, ref1;
      if (node === this.nid) {
        ref = this.nodes;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          n = ref[i];
          marked = player.tree.get(n).mark(player, n);
          if (marked > -1) {
            return marked;
          }
        }
        return -1;
      } else {
        ref1 = this.nodes;
        for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
          n = ref1[i];
          if (node <= n) {
            marked = player.tree.get(n).mark(player, node);
            if (marked > -1) {
              return marked;
            } else {
              node = n + 1;
            }
          }
        }
      }
      return -1;
    };

    BlockNode.prototype.size = function() {
      return this.nodes.length;
    };

    BlockNode.prototype.toJSON = function() {
      return {
        nid: this.nid,
        node: 'block',
        nodes: this.nodes
      };
    };

    BlockNode.parse = function(node, tree, memory) {
      var nid, nodes;
      nodes = [];
      node.children('li.node').each(function(index, element) {
        var child;
        child = Node.parse($(element), tree, memory);
        tree.push(child);
        return nodes[index] = child.nid;
      });
      nid = tree.length;
      return new BlockNode(nid, nodes);
    };

    return BlockNode;

  })(Node);

  CommentNode = (function(superClass) {
    extend(CommentNode, superClass);

    function CommentNode(nid1, comment1) {
      this.nid = nid1;
      this.comment = comment1;
    }

    CommentNode.prototype.execute = function(player, node) {
      return {
        value: false
      };
    };

    CommentNode.prototype.mark = function(player, node) {
      return -1;
    };

    CommentNode.prototype.toJSON = function() {
      return {
        nid: this.nid,
        node: 'comment',
        comment: this.comment
      };
    };

    CommentNode.parse = function(node, tree, memory) {
      var comment, nid;
      comment = CommentNode.findSubNode(node, '.comment-text').val();
      nid = tree.length;
      return new CommentNode(nid, comment);
    };

    return CommentNode;

  })(Node);

  CompareNode = (function(superClass) {
    extend(CompareNode, superClass);

    function CompareNode(nid1, left1, right1, operator1) {
      this.nid = nid1;
      this.left = left1;
      this.right = right1;
      this.operator = operator1;
    }

    CompareNode.prototype.execute = function(player, node) {
      var leftVal, rightVal;
      leftVal = this.executeValue(this.left, player);
      rightVal = this.executeValue(this.right, player);
      player.stats.incCompareOps();
      switch (this.operator) {
        case 'le':
          return {
            value: leftVal <= rightVal
          };
        case 'lt':
          return {
            value: leftVal < rightVal
          };
        case 'eq':
          return {
            value: leftVal === rightVal
          };
        case 'gt':
          return {
            value: leftVal > rightVal
          };
        case 'ge':
          return {
            value: leftVal >= rightVal
          };
        case 'ne':
          return {
            value: leftVal !== rightVal
          };
        default:
          throw new Error("CompareNode: unknown operator: '" + this.operator + "'!");
      }
    };

    CompareNode.prototype.toJSON = function() {
      return {
        nid: this.nid,
        node: 'compare',
        left: this.left,
        right: this.right,
        operator: this.operator
      };
    };

    CompareNode.parse = function(node, tree, memory) {
      var left, nid, operator, right;
      left = CompareNode.parseAndCheckValue('.compare-left', node, memory);
      right = CompareNode.parseAndCheckValue('.compare-right', node, memory);
      CompareNode.validate(node, (left != null) && (right != null));
      operator = CompareNode.findSubNode(node, '.compare-operation').val();
      nid = tree.length;
      return new CompareNode(nid, left, right, operator);
    };

    return CompareNode;

  })(Node);

  FunctionNode = (function(superClass) {
    extend(FunctionNode, superClass);

    function FunctionNode(nid1, callee1, paramsLine1, params1) {
      this.nid = nid1;
      this.callee = callee1;
      this.paramsLine = paramsLine1;
      this.params = params1;
    }

    FunctionNode.prototype.execute = function(player, node) {
      var curNode, scope, value;
      scope = player.scope;
      curNode = $('#scope-' + scope + ' .node_' + this.nid);
      if ((curNode.data('return-value') != null)) {
        value = curNode.data('return-value');
        curNode.removeData('return-value');
        return {
          value: value
        };
      }
      return this.callFunction(player, curNode);
    };

    FunctionNode.prototype.callFunction = function(player, node) {
      var head, newScope, params;
      newScope = player.scope + 1;
      head = $('<a/>').data('target', '#scope-' + newScope).addClass('scope-' + newScope);
      head.attr('aria-controls', 'scope-' + newScope).attr('role', 'tab').attr('data-toggle', 'tab');
      head.append($('<i/>').addClass('fa fa-spinner fa-pulse'));
      $('#scopes-head').append($('<li/>').attr('role', 'presentation').append(head));
      $('#scopes-body').append($('<div/>').attr('role', 'tabpanel').addClass('tab-pane').attr('id', 'scope-' + newScope));
      $.ajax("api/scope.php", {
        type: 'POST',
        data: {
          aid: this.callee,
          scope: newScope,
          lang: window.current.lang
        },
        dataType: 'json',
        async: false
      }).done(function(data) {
        $('#scope-' + newScope).append(data['algorithm']);
        return head.text(data['name']);
      }).fail(function() {
        $('#scope-' + newScope).remove();
        head.parent().remove();
        player.handleError(new ExecutionError('function_load', [name]));
        return false;
      });
      params = this.paramsLine;
      return {
        scope: newScope,
        node: this.nid,
        params: params
      };
    };

    FunctionNode.prototype.toJSON = function() {
      return {
        nid: this.nid,
        node: 'function',
        callee: this.callee,
        paramsLine: this.paramsLine,
        params: this.params
      };
    };

    FunctionNode.parse = function(node, tree, memory) {
      var callee, j, len, nid, par, params, paramsLine, paramsLineError, paramsRaw, ref;
      callee = node.data('callee-id');
      paramsLine = [];
      paramsRaw = FunctionNode.findSubNode(node, '.act-pars-line').val();
      paramsLineError = false;
      if (paramsRaw !== '') {
        ref = paramsRaw.split(';');
        for (j = 0, len = ref.length; j < len; j++) {
          par = ref[j];
          par = FunctionNode.parseValue(par, node, memory);
          if (par == null) {
            paramsLineError = true;
          } else {
            paramsLine.push(par);
          }
        }
      }
      params = BlockNode.parse(FunctionNode.findSubNode(node, '.act-pars'), tree, memory);
      tree.push(params);
      FunctionNode.validate(node, callee > 0 && !paramsLineError);
      nid = tree.length;
      return new FunctionNode(nid, callee, paramsLine, params.nid);
    };

    return FunctionNode;

  })(Node);

  IfNode = (function(superClass) {
    extend(IfNode, superClass);

    function IfNode(nid1, condition1, ifBody1, elseBody1, op1) {
      this.nid = nid1;
      this.condition = condition1;
      this.ifBody = ifBody1;
      this.elseBody = elseBody1;
      this.op = op1;
    }

    IfNode.prototype.execute = function(player, node) {
      var cond, condRetVal, size, value;
      if (node <= this.condition) {
        cond = player.tree.get(this.condition);
        size = cond.size();
        if (size === 1) {
          condRetVal = cond.execute(player, node);
        } else if (size > 1) {
          condRetVal = cond.executeAll(player, node, this.op);
        } else {
          throw new ExecutionError('no_condition', []);
        }
        value = condRetVal.value + 0 !== 0;
        if (condRetVal.next > -1) {
          return {
            next: condRetVal.next,
            value: value
          };
        } else if (value) {
          return {
            next: this.ifBody,
            value: value
          };
        } else {
          return {
            next: this.elseBody,
            value: value
          };
        }
      } else if (node <= this.ifBody) {
        return player.tree.get(this.ifBody).execute(player, node);
      } else {
        return player.tree.get(this.elseBody).execute(player, node);
      }
    };

    IfNode.prototype.mark = function(player, node) {
      if (node === this.nid) {
        return player.tree.get(this.condition).mark(player, this.condition);
      } else if (node <= this.condition) {
        return player.tree.get(this.condition).mark(player, node);
      } else if (node <= this.ifBody) {
        return player.tree.get(this.ifBody).mark(player, node);
      } else {
        return player.tree.get(this.elseBody).mark(player, node);
      }
    };

    IfNode.prototype.toJSON = function() {
      return {
        nid: this.nid,
        node: 'if',
        condition: this.condition,
        ifBody: this.ifBody,
        elseBody: this.elseBody,
        op: this.op
      };
    };

    IfNode.parse = function(node, tree, memory) {
      var condition, elseBody, ifBody, nid, op, size;
      condition = BlockNode.parse(IfNode.findSubNode(node, '.if-condition'), tree, memory);
      tree.push(condition);
      ifBody = BlockNode.parse(IfNode.findSubNode(node, '.if-body'), tree, memory);
      tree.push(ifBody);
      elseBody = BlockNode.parse(IfNode.findSubNode(node, '.if-else'), tree, memory);
      tree.push(elseBody);
      size = condition.size();
      IfNode.validate(node, size > 0);
      op = IfNode.findSubNode(node, '.if-operator');
      if (size > 1) {
        op.show();
      } else {
        op.hide();
      }
      nid = tree.length;
      return new IfNode(nid, condition.nid, ifBody.nid, elseBody.nid, op.val());
    };

    return IfNode;

  })(Node);

  IncNode = (function(superClass) {
    extend(IncNode, superClass);

    function IncNode(nid1, variable1, operator1) {
      this.nid = nid1;
      this.variable = variable1;
      this.operator = operator1;
    }

    IncNode.prototype.execute = function(player, node) {
      var index, newValue, value, vid;
      vid = this.variable.vid;
      value = this.executeValue(this.variable, player);
      if (this.operator === 'inc') {
        newValue = value + 1;
      } else {
        newValue = value - 1;
      }
      if (this.variable.kind === 'index') {
        index = this.executeValue(this.variable.index, player);
        player.memory.arraySet(vid, index, newValue);
        player.stats.writeArrayVar(vid, index, newValue);
      } else {
        player.memory.set(vid, newValue);
        player.stats.writeVar(vid, newValue);
      }
      return {
        value: value
      };
    };

    IncNode.prototype.toJSON = function() {
      return {
        nid: this.nid,
        node: 'inc',
        "var": this.variable,
        operator: this.operator
      };
    };

    IncNode.parse = function(node, tree, memory) {
      var nid, operator, variable;
      variable = IncNode.parseAndCheckVar('.inc-var', node, memory);
      IncNode.validate(node, variable != null);
      operator = IncNode.findSubNode(node, '.inc-operation').val();
      nid = tree.length;
      return new IncNode(nid, variable, operator);
    };

    return IncNode;

  })(Node);

  ReturnNode = (function(superClass) {
    extend(ReturnNode, superClass);

    function ReturnNode(nid1, value1) {
      this.nid = nid1;
      this.value = value1;
    }

    ReturnNode.prototype.execute = function(player, node) {
      var value;
      value = this.executeValue(this.value, player);
      $('#scope-' + player.scope + ' .return-value').val(value).focus();
      return -1;
    };

    ReturnNode.prototype.toJSON = function() {
      return {
        nid: this.nid,
        node: 'return',
        value: this.value
      };
    };

    ReturnNode.parse = function(node, tree, memory) {
      var nid, value;
      value = ReturnNode.parseAndCheckValue('.return-value', node, memory);
      ReturnNode.validate(node, value != null);
      nid = tree.length;
      return new ReturnNode(nid, value);
    };

    return ReturnNode;

  })(Node);

  SwapNode = (function(superClass) {
    extend(SwapNode, superClass);

    function SwapNode(nid1, left1, right1) {
      this.nid = nid1;
      this.left = left1;
      this.right = right1;
    }

    SwapNode.prototype.execute = function(player, node) {
      var leftVal, rightVal;
      leftVal = this.executeValue(this.left, player);
      rightVal = this.executeValue(this.right, player);
      this.writeVar(this.left, rightVal, player);
      this.writeVar(this.right, leftVal, player);
      return {
        value: leftVal !== rightVal
      };
    };

    SwapNode.prototype.toJSON = function() {
      return {
        nid: this.nid,
        node: 'swap',
        left: this.left,
        right: this.right
      };
    };

    SwapNode.parse = function(node, tree, memory) {
      var left, nid, right;
      left = SwapNode.parseAndCheckValue('.swap-left', node, memory);
      right = SwapNode.parseAndCheckValue('.swap-right', node, memory);
      SwapNode.validate(node, (left != null) && (right != null));
      nid = tree.length;
      return new SwapNode(nid, left, right);
    };

    return SwapNode;

  })(Node);

  ValueNode = (function(superClass) {
    extend(ValueNode, superClass);

    function ValueNode(nid1, value1) {
      this.nid = nid1;
      this.value = value1;
    }

    ValueNode.prototype.execute = function(player, node) {
      return {
        value: this.executeValue(this.value, player)
      };
    };

    ValueNode.prototype.toJSON = function() {
      return {
        nid: this.nid,
        node: 'value',
        value: this.value
      };
    };

    ValueNode.parse = function(node, tree, memory) {
      var nid, value;
      value = ValueNode.parseAndCheckValue('.value-var', node, memory);
      ValueNode.validate(node, value != null);
      nid = tree.length;
      return new ValueNode(nid, value);
    };

    return ValueNode;

  })(Node);

  WhileNode = (function(superClass) {
    extend(WhileNode, superClass);

    function WhileNode(nid1, condition1, body1, op1) {
      this.nid = nid1;
      this.condition = condition1;
      this.body = body1;
      this.op = op1;
    }

    WhileNode.prototype.execute = function(player, node) {
      var bodyValue, cond, condValue, size;
      if (node <= this.condition) {
        cond = player.tree.get(this.condition);
        size = cond.size();
        if (size === 1) {
          condValue = cond.execute(player, node);
        } else if (size > 1) {
          condValue = cond.executeAll(player, node, this.op);
        } else {
          throw new ExecutionError('no_condition', []);
        }
        if (condValue.next > -1) {
          return {
            next: condValue.next
          };
        } else if (condValue.value) {
          return {
            next: this.body
          };
        } else {
          return {};
        }
      } else if (node <= this.body) {
        bodyValue = player.tree.get(this.body).execute(player, node);
        if ((bodyValue.scope != null)) {
          return bodyValue;
        } else if (bodyValue.next != null) {
          return {
            next: bodyValue.next
          };
        } else {
          return {
            next: this.condition
          };
        }
      }
    };

    WhileNode.prototype.mark = function(player, node) {
      var body, condition;
      condition = player.tree.get(this.condition);
      if (node === this.nid) {
        return condition.mark(player, this.condition);
      } else if (node <= this.condition) {
        return condition.mark(player, node);
      } else {
        body = player.tree.get(this.body);
        if (body.size()) {
          return body.mark(player, node);
        } else {
          return condition.mark(player, this.condition);
        }
      }
    };

    WhileNode.prototype.toJSON = function() {
      return {
        nid: this.nid,
        node: 'while',
        condition: this.condition,
        body: this.body,
        op: this.op
      };
    };

    WhileNode.parse = function(node, tree, memory) {
      var body, condition, nid, op, size;
      condition = BlockNode.parse(WhileNode.findSubNode(node, '.while-condition'), tree, memory);
      tree.push(condition);
      body = BlockNode.parse(WhileNode.findSubNode(node, '.while-body'), tree, memory);
      tree.push(body);
      size = condition.size();
      WhileNode.validate(node, size > 0);
      op = WhileNode.findSubNode(node, '.while-operator');
      if (size > 1) {
        op.show();
      } else {
        op.hide();
      }
      nid = tree.length;
      return new WhileNode(nid, condition.nid, body.nid, op.val());
    };

    return WhileNode;

  })(Node);

  window.Tree = (function() {
    function Tree(scope1) {
      this.scope = scope1;
      this.memory = new Memory($('#scope-' + this.scope + ' .variables>tbody'));
      this.reset();
    }

    Tree.prototype.execute = function(player, node) {
      return this.get(this.root).execute(player, node);
    };

    Tree.prototype.mark = function(player, node) {
      return this.get(this.root).mark(player, node);
    };

    Tree.prototype.get = function(nid) {
      return this.nodes[nid];
    };

    Tree.prototype.reset = function() {
      var rootNode;
      this.memory.reset();
      this.nodes = [];
      rootNode = BlockNode.parse($('#scope-' + this.scope + ' .node_root'), this.nodes, this.memory);
      this.root = this.nodes.length;
      return this.nodes.push(rootNode);
    };

    Tree.prototype.toJSON = function() {
      var i, j, json, len, node, ref;
      json = [];
      ref = this.nodes;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        node = ref[i];
        json[i] = node.toJSON();
      }
      return json;
    };

    Tree.toJSON = function() {
      return new this(0).toJSON();
    };

    return Tree;

  })();

  window.Memory = (function() {
    function Memory(table) {
      this.table = table;
      this.reset = bind(this.reset, this);
      this.arraySet = bind(this.arraySet, this);
      this.arrayGet = bind(this.arrayGet, this);
      this.arrayCheck = bind(this.arrayCheck, this);
      this.set = bind(this.set, this);
      this.get = bind(this.get, this);
      this.find = bind(this.find, this);
      this.count = bind(this.count, this);
      this.memory = new Object();
      this.original = new Object();
      this.table.children().not('#var-prototype').each((function(_this) {
        return function(index, element) {
          var array, name, value, vid;
          vid = $(element).data('vid');
          name = $(element).data('name');
          value = $(element).data('value');
          array = $(element).data('type').substr(0, 5) === 'array';
          _this.memory[vid] = {
            vid: vid,
            name: name,
            value: value,
            array: array,
            count: 0
          };
          return _this.original[vid] = {
            vid: vid,
            name: name,
            value: value,
            array: array,
            count: 0
          };
        };
      })(this));
    }

    Memory.prototype.count = function(vid) {
      var variable;
      variable = this.memory[vid];
      return ++variable.count;
    };

    Memory.prototype.find = function(name) {
      var vid;
      vid = -1;
      $.each(this.memory, function(index, elem) {
        if (elem.name === name) {
          return vid = elem.vid;
        }
      });
      return vid;
    };

    Memory.prototype.get = function(vid) {
      return this.memory[vid];
    };

    Memory.prototype.set = function(vid, value) {
      var error, error1;
      try {
        value.split(',');
        this.memory[vid].array = true;
      } catch (error1) {
        error = error1;
        this.memory[vid].array = false;
      }
      return this.memory[vid].value = value;
    };

    Memory.prototype.arrayCheck = function(vid, index) {
      var array, variable;
      variable = this.get(vid);
      if (!variable.array) {
        throw new ExecutionError('no_array_for_index', [variable.name]);
      }
      array = variable.value.split(',');
      if (index < 0 || array.length <= index) {
        throw new ExecutionError('index_out_of_bounds', [variable.name, index, array.length]);
      }
      return array;
    };

    Memory.prototype.arrayGet = function(vid, index) {
      var array, value;
      array = this.arrayCheck(vid, index);
      value = array[index];
      if (parseInt(value) + '' === value) {
        return parseInt(value);
      } else {
        return value;
      }
    };

    Memory.prototype.arraySet = function(vid, index, value) {
      var array;
      array = this.arrayCheck(vid, index);
      array[index] = value;
      return this.set(vid, array.join(','));
    };

    Memory.prototype.reset = function() {
      return $.each(this.original, (function(_this) {
        return function(index, elem) {
          _this.memory[index].value = elem.value;
          return _this.memory[index].count = 0;
        };
      })(this));
    };

    return Memory;

  })();

  window.DataType = (function() {
    function DataType() {}

    DataType.parse = function(value) {
      var boolVal, intVal;
      intVal = parseInt(value);
      if (intVal + "" === value) {
        return {
          type: 'int',
          value: intVal
        };
      }
      boolVal = value.toLowerCase();
      if (boolVal === 'true' || boolVal === 'false') {
        return {
          type: 'bool',
          value: boolVal === 'true'
        };
      }
      return false;
    };

    return DataType;

  })();

  window.ExecutionError = (function(superClass) {
    extend(ExecutionError, superClass);

    function ExecutionError(message, parts) {
      this.message = message;
      this.parts = parts;
    }

    return ExecutionError;

  })(Error);

}).call(this);
